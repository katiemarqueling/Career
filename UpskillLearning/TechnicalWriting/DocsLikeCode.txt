Docs Like Code Notes

- Chapter 1: introducing docs-like-code
    - user-centered docs that are technically accurate
    - currently developed by using Agile techniques
    - purpose is to aid in the effective use of technology
    - treat docs like code:
        - store the doc source files in a version control system
        - build the doc artifacts automatically
          ensure that a trusted set of reviewers meticulously review the documents
        - publish the artifacts without much human intervention
    - JavaDoc, REST API, Django
    - goals of docs like code:
        - promote collaboration: GitHub social network, continuous integration, 
          automated testing, and incremental improvement
        - get long-tail contributions: rise of the niche, docs that are constructed 
          from obscure knowledge gathering and hard-to-find information, specialist 
          in the topic to help you understand, don't belittle a complex software product
          that only a few people understand deeply 
        - track doc bugs like code bugs: tracked incremental improvement
        - get better reviews: reviewers can see what was changed before approving, 
          notifications that something was changed
        - make beautiful docs: clean, useful, well organized docs, Sphinx, Bootstrap
        - use developer tools and workflows: published automatically, can focus on content
          not build, write code to format for you, do not guard writing knowledge or 
          tools in order to protect jobs
        - get value from cost effective tools: already have GitHub, don't need specialized equipment
- Chapter 2: plan for docs-like-code
    - source file organization (separate repo, multiple repos, or with code)
        - users: make sure your user needs what you are actually creating
        - contributors: create a separate repo if developer is confused by docs, more accurate = same repo
        - reviewers: what collaborators are the best to review and what is their preference
        - content size: do reviewers need look at everything or just technical parts (separate repos)
        - deployed docs: is everything being released together
        - translated docs: if freeze for translation is needed, split code and docs
    - inclusion mechanisms
        - enales authors to insert a reference to other content and pull tha content into
          the location at build time
        - reuses smaller pieces of information
    - speciality information - REST API docs:
        - DXs can let multiple contributors work on one file at the same time
        - API complexity
            - methods: HTTP GET, PUT, POST, PATCH, DELETE
            - headers: any extra headers API
            - parameters: what query, template, and body parameters are required
            - error codes: are errors easy to understand, or do you need to document what they mean
        - API source frameworks/API description language
            - OpenAPI (Swagger): JSON, YAML
            - RESTful API: YAML
            - API Blueprint: Markdown
        - API life cycle
            - github is not a API management platform
            - also need security, parameter testing, monitoring, monetizing, visualizing, webhooks, 
              terms of service, discovery, and the voice for the API
            - API life cycle: Subway Map API by Kin Lane
        - API user docs
            - API docs make API findable and usable
            - need auto-generated reference docs that describe architecture and why it exists, along
              with code samples and tutorials
        - API guidelines
            - GitHub for REST APIs: document expectations for source file markup, contribution rules,
              completeness definitions, review guidelines, and quality indicators
- Chapter 3: optimize docs-like code workflows
    - basic workflows
        - centralized: working in main
        - feature branch: work in separate branch
        - gitflow: work in feature branch but with specific guidelines
        - forking: work in independent fork and merge when you want to
    - the further the documents are from the code, the harder it is to keep them in sync
